name: Validate Tailwind Patch Migration Report (Affected Shards)

on:
  pull_request:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  detect-shards:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      has_changes: ${{ steps.resolve.outputs.has_changes }}
      matrix: ${{ steps.resolve.outputs.matrix }}
      shards: ${{ steps.resolve.outputs.shards }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Resolve affected shards
        id: resolve
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          BASE_SHA: ${{ github.event.pull_request.base.sha || '' }}
          HEAD_SHA: ${{ github.sha }}
          BASE_REF: ${{ github.base_ref }}
        run: |
          set -euo pipefail

          node - <<'NODE'
          const fs = require('node:fs')
          const { execFileSync } = require('node:child_process')

          const defaultConfig = {
            runAllPatterns: [
              'packages/tailwindcss-patch/**',
              'pnpm-lock.yaml',
              'pnpm-workspace.yaml',
              'package.json',
              'turbo.json',
              '.npmrc',
              '.nvmrc',
              '.node-version',
              '.github/workflows/**',
            ],
            shards: [
              {
                name: 'root',
                reportFile: '.tw-patch/migrate-report-root.json',
                matchPatterns: ['tailwindcss-patch.config.*', 'tailwindcss-mangle.config.*'],
              },
              { name: 'apps', reportFile: '.tw-patch/migrate-report-apps.json', matchPatterns: ['apps/**'] },
              {
                name: 'packages',
                reportFile: '.tw-patch/migrate-report-packages.json',
                matchPatterns: ['packages/**'],
              },
            ],
          }

          const configPath = '.tw-patch/ci-shards.json'

          const normalizeConfig = (value) => {
            if (!value || typeof value !== 'object') return defaultConfig
            const runAllPatterns = Array.isArray(value.runAllPatterns)
              ? value.runAllPatterns.filter((p) => typeof p === 'string' && p.length > 0)
              : defaultConfig.runAllPatterns
            const shards = Array.isArray(value.shards)
              ? value.shards
                  .filter((s) => s && typeof s === 'object')
                  .map((s) => ({
                    name: typeof s.name === 'string' ? s.name : '',
                    reportFile: typeof s.reportFile === 'string' ? s.reportFile : '',
                    matchPatterns: Array.isArray(s.matchPatterns)
                      ? s.matchPatterns.filter((p) => typeof p === 'string' && p.length > 0)
                      : [],
                  }))
                  .filter((s) => s.name && s.reportFile && s.matchPatterns.length > 0)
              : defaultConfig.shards

            if (shards.length === 0) return defaultConfig
            return { runAllPatterns, shards }
          }

          const loadConfig = () => {
            if (!fs.existsSync(configPath)) return defaultConfig
            try {
              const parsed = JSON.parse(fs.readFileSync(configPath, 'utf8'))
              const config = normalizeConfig(parsed)
              console.log(`::notice::Loaded shard config from ${configPath}`)
              return config
            } catch (error) {
              console.log(`::warning::Invalid ${configPath}, fallback to defaults: ${error.message}`)
              return defaultConfig
            }
          }

          const globToRegExp = (pattern) => {
            const escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&')
            const withGlob = escaped
              .replace(/\*\*/g, '__TW_PATCH_GLOBSTAR__')
              .replace(/\*/g, '[^/]*')
              .replace(/__TW_PATCH_GLOBSTAR__/g, '.*')
              .replace(/\?/g, '.')
            return new RegExp(`^${withGlob}$`)
          }

          const matchesAny = (value, patterns) => patterns.some((pattern) => globToRegExp(pattern).test(value))

          const runGit = (args) => execFileSync('git', args, { encoding: 'utf8' }).trim()

          const hasCommit = (sha) => {
            if (!sha) return false
            try {
              execFileSync('git', ['cat-file', '-e', `${sha}^{commit}`], { stdio: 'ignore' })
              return true
            } catch {
              return false
            }
          }

          const config = loadConfig()
          const allShardNames = config.shards.map((s) => s.name)
          const eventName = process.env.EVENT_NAME || ''
          const headSha = process.env.HEAD_SHA || 'HEAD'
          const baseRef = process.env.BASE_REF || ''
          const outputPath = process.env.GITHUB_OUTPUT

          const writeOutputs = (payload) => {
            const lines = [
              `has_changes=${payload.hasChanges ? 'true' : 'false'}`,
              `shards=${payload.shards.length > 0 ? payload.shards.join(',') : 'none'}`,
              `matrix=${JSON.stringify({ shard: payload.matrix })}`,
            ]
            fs.appendFileSync(outputPath, `${lines.join('\n')}\n`)
          }

          if (eventName === 'workflow_dispatch') {
            console.log('::notice::workflow_dispatch => run all shards')
            writeOutputs({
              hasChanges: true,
              shards: allShardNames,
              matrix: config.shards.map((s) => ({ name: s.name, report_file: s.reportFile })),
            })
            process.exit(0)
          }

          let baseSha = process.env.BASE_SHA || ''
          if (!hasCommit(baseSha) && baseRef) {
            try {
              baseSha = runGit(['merge-base', 'HEAD', `origin/${baseRef}`])
              console.log(`::notice::Fallback base resolved by merge-base: ${baseSha}`)
            } catch {
              console.log('::warning::Unable to resolve PR base by merge-base, run all shards')
              writeOutputs({
                hasChanges: true,
                shards: allShardNames,
                matrix: config.shards.map((s) => ({ name: s.name, report_file: s.reportFile })),
              })
              process.exit(0)
            }
          }

          if (!baseSha) {
            console.log('::warning::Missing base sha, run all shards')
            writeOutputs({
              hasChanges: true,
              shards: allShardNames,
              matrix: config.shards.map((s) => ({ name: s.name, report_file: s.reportFile })),
            })
            process.exit(0)
          }

          let changedFiles = []
          try {
            changedFiles = runGit(['diff', '--name-only', baseSha, headSha])
              .split('\n')
              .map((f) => f.trim())
              .filter(Boolean)
          } catch (error) {
            console.log(`::warning::git diff failed (${error.message}), run all shards`)
            writeOutputs({
              hasChanges: true,
              shards: allShardNames,
              matrix: config.shards.map((s) => ({ name: s.name, report_file: s.reportFile })),
            })
            process.exit(0)
          }

          if (changedFiles.length === 0) {
            console.log('::notice::No changed files in PR diff')
            writeOutputs({ hasChanges: false, shards: [], matrix: [] })
            process.exit(0)
          }

          if (changedFiles.some((file) => matchesAny(file, config.runAllPatterns))) {
            console.log('::notice::Matched runAllPatterns => run all shards')
            writeOutputs({
              hasChanges: true,
              shards: allShardNames,
              matrix: config.shards.map((s) => ({ name: s.name, report_file: s.reportFile })),
            })
            process.exit(0)
          }

          const matched = config.shards.filter((shard) => changedFiles.some((file) => matchesAny(file, shard.matchPatterns)))

          if (matched.length === 0) {
            console.log('::notice::Changes do not affect configured shard patterns')
            writeOutputs({ hasChanges: false, shards: [], matrix: [] })
            process.exit(0)
          }

          writeOutputs({
            hasChanges: true,
            shards: matched.map((s) => s.name),
            matrix: matched.map((s) => ({ name: s.name, report_file: s.reportFile })),
          })
          NODE

  validate-migration-report:
    needs: detect-shards
    if: needs.detect-shards.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-shards.outputs.matrix) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 20
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Ensure migration report is up-to-date (${{ matrix.shard.name }})
        shell: bash
        run: |
          include_args=()
          case "${{ matrix.shard.name }}" in
            root)
              include_args+=(--include "tailwindcss-patch.config.*")
              include_args+=(--include "tailwindcss-mangle.config.*")
              ;;
            apps)
              include_args+=(--include "apps/**")
              ;;
            packages)
              include_args+=(--include "packages/**")
              ;;
            *)
              echo "::error::Unknown shard: ${{ matrix.shard.name }}"
              exit 1
              ;;
          esac

          pnpm dlx tw-patch migrate --workspace --check "${include_args[@]}" --report-file "${{ matrix.shard.report_file }}"

      - name: Validate migration report (${{ matrix.shard.name }})
        shell: bash
        run: |
          mkdir -p .tw-patch
          set +e
          pnpm dlx tw-patch validate --report-file "${{ matrix.shard.report_file }}" --strict --json > ".tw-patch/validate-result-${{ matrix.shard.name }}.json"
          status=$?
          set -e

          if [ "$status" -ne 0 ]; then
            cat ".tw-patch/validate-result-${{ matrix.shard.name }}.json"
          fi

          case "$status" in
            0)  echo "validate ok (${{ matrix.shard.name }})" ;;
            21) echo "::error::Migration report schema/kind incompatible (${{ matrix.shard.name }})"; exit 1 ;;
            22) echo "::error::Missing backups under --strict (${{ matrix.shard.name }})"; exit 1 ;;
            23) echo "::error::I/O failure while reading report/backups (${{ matrix.shard.name }})"; exit 1 ;;
            *)  echo "::error::Unknown validate failure (exit $status, shard=${{ matrix.shard.name }})"; exit "$status" ;;
          esac

      - name: Upload validate result (${{ matrix.shard.name }})
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tw-patch-validate-result-${{ matrix.shard.name }}
          path: .tw-patch/validate-result-${{ matrix.shard.name }}.json

  no-affected-shards:
    needs: detect-shards
    if: needs.detect-shards.outputs.has_changes != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Skip
        run: echo "No affected shards for migration report validation."
